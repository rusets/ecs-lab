name: CD – Infra Apply/Destroy + ECS Deploy

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "apply or destroy"
        required: true
        type: choice
        options: [ apply, destroy ]
        default: apply
      imageSha:
        description: "Optional image SHA tag (default: last commit)"
        required: false
        type: string

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 097635932419.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: myapp
  CLUSTER_NAME: docker-ecs-deployment-cluster
  SERVICE_NAME: docker-ecs-deployment-svc
  IMAGE_TAG: latest
  IMAGE_SHA_TAG: ${{ inputs.imageSha && inputs.imageSha || github.sha }}
  TG_NAME: docker-ecs-deployment-tg
  TF_WORKING_DIR: infra
  TF_PLUGIN_CACHE_DIR: ${{ runner.temp }}/tfplugincache

permissions:
  id-token: write
  contents: read

concurrency:
  group: cd-${{ github.ref }}-${{ github.event.inputs.mode || 'apply' }}
  cancel-in-progress: false

jobs:
  terraform:
    name: Terraform ${{ github.event.inputs.mode || 'apply' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (terraform role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::097635932419:role/github-actions-terraform-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Ensure TF plugin cache dir exists
        run: mkdir -p "${{ env.TF_PLUGIN_CACHE_DIR }}"

      - name: Restore Terraform plugin cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: tf-plugins-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('**/*.tf', '**/*.tfvars', '**/.terraform.lock.hcl') }}
          restore-keys: |
            tf-plugins-${{ runner.os }}-${{ runner.arch }}-

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          TF_PLUGIN_CACHE_DIR: ${{ env.TF_PLUGIN_CACHE_DIR }}
          TF_IN_AUTOMATION: 1
        run: terraform init -reconfigure -upgrade -input=false -no-color

      - name: Terraform Destroy
        if: ${{ github.event.inputs.mode == 'destroy' }}
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform destroy -auto-approve -no-color

      - name: Terraform Plan
        if: ${{ github.event.inputs.mode != 'destroy' }}
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform plan -input=false -no-color -out=tfplan

      - name: Terraform Apply
        if: ${{ github.event.inputs.mode != 'destroy' }}
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform apply -input=false -no-color -auto-approve tfplan

  build_and_deploy:
    name: Build → Push → Register TD → Update Service → Smart Wait
    needs: terraform
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.mode != 'destroy' }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (ecs role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::097635932419:role/github-actions-ecs-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        run: |
          docker build -f app/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG app
          docker tag  $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_SHA_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_SHA_TAG

      - name: Ensure jq is installed
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Get current TaskDef ARN from Service
        id: svc
        run: |
          aws ecs describe-services \
            --cluster "${CLUSTER_NAME}" \
            --services "${SERVICE_NAME}" \
            --region "${AWS_REGION}" \
            --query "services[0].taskDefinition" \
            --output text > td_arn.txt
          echo "td_arn=$(cat td_arn.txt)" >> $GITHUB_OUTPUT

      - name: Get full TaskDef JSON
        run: |
          aws ecs describe-task-definition \
            --task-definition "${{ steps.svc.outputs.td_arn }}" \
            --region "${AWS_REGION}" \
            --query "taskDefinition" > taskdef.json

      - name: Build new TaskDef JSON with new image (SHA tag)
        run: |
          CN=$(jq -r '.containerDefinitions[0].name' taskdef.json)
          jq --arg IMG "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_SHA_TAG" --arg CN "$CN" '
            del(.revision, .status, .taskDefinitionArn, .requiresAttributes, .compatibilities, .registeredBy, .registeredAt)
            | .containerDefinitions = (.containerDefinitions | map(if .name == $CN then .image = $IMG else . end))
          ' taskdef.json > register.json

      - name: Register new TaskDef
        id: register_td
        run: |
          NEW_TD_ARN=$(aws ecs register-task-definition \
            --region "${AWS_REGION}" \
            --cli-input-json file://register.json \
            --query "taskDefinition.taskDefinitionArn" \
            --output text)
          echo "new_td_arn=${NEW_TD_ARN}" >> $GITHUB_OUTPUT

      - name: Update Service to new TaskDef
        run: |
          aws ecs update-service \
            --cluster "${CLUSTER_NAME}" \
            --service "${SERVICE_NAME}" \
            --task-definition "${{ steps.register_td.outputs.new_td_arn }}" \
            --region "${AWS_REGION}"

      - name: Wait for service stability (smart logs)
        run: |
          END=$((SECONDS+900))
          while [ $SECONDS -lt $END ]; do
            aws ecs describe-services \
              --cluster "$CLUSTER_NAME" \
              --services "$SERVICE_NAME" \
              --region "$AWS_REGION" \
              --query 'services[0].{desired:desiredCount,running:runningCount,events:events[0:3].[message]}' \
              --output table
            sleep 20
          done
          exit 1
        